<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Basic Data Manipulation</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Basic Data Manipulation</h1>

<h2>Reading and Saving data</h2>

<p>Let&#39;s say we want to:</p>

<ul>
<li>read this <a href="http://data.princeton.edu/wws509/datasets/effort.dat">http://data.princeton.edu/wws509/datasets/effort.dat</a> file</li>
<li>make some summaries</li>
<li>save it to a cvs file in our computer</li>
</ul>

<pre><code class="r">fpe &lt;- read.table(&quot;http://data.princeton.edu/wws509/datasets/effort.dat&quot;)

head(fpe)
</code></pre>

<pre><code>##           setting effort change
## Bolivia        46      0      1
## Brazil         74      0     10
## Chile          89     16     29
## Colombia       77     16     25
## CostaRica      84     21     29
## Cuba           89     15     40
</code></pre>

<pre><code class="r">names(fpe)
</code></pre>

<pre><code>## [1] &quot;setting&quot; &quot;effort&quot;  &quot;change&quot;
</code></pre>

<pre><code class="r">nrow(fpe)
</code></pre>

<pre><code>## [1] 20
</code></pre>

<pre><code class="r">ncol(fpe)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">summary(fpe)
</code></pre>

<pre><code>##     setting         effort          change    
##  Min.   :35.0   Min.   : 0.00   Min.   : 0.0  
##  1st Qu.:66.0   1st Qu.: 3.00   1st Qu.: 5.5  
##  Median :74.0   Median : 8.00   Median :10.5  
##  Mean   :72.1   Mean   : 9.55   Mean   :14.3  
##  3rd Qu.:84.0   3rd Qu.:15.25   3rd Qu.:22.8  
##  Max.   :91.0   Max.   :23.00   Max.   :40.0
</code></pre>

<pre><code class="r">write.table(fpe, file = &quot;./effort.dat&quot;, sep = &quot;;&quot;)
write.csv(fpe, file = &quot;./effort.csv&quot;)  # we can also save as a csv
</code></pre>

<p>Other functions are</p>

<ul>
<li>dput(x, file): opens file and deparses the object x into that file</li>
<li>dget(file): parses the file and returns an object (eg: df &lt;- dget(&ldquo;file.txt&rdquo;))</li>
<li>dump(vector of objects, file): takes a vector of names of R objects and produces text representations of the objects on a file</li>
<li>source(file): recovers the objects saved by dump</li>
<li>save: writes an external representation of R objects to the specified file</li>
<li>load: reload datasets written with the function save</li>
<li>serialize(x, file): turns object x into a binary file</li>
<li>unserialize(file): recovers binary object kept on file</li>
</ul>

<h2>Vectors</h2>

<p>Vectors contain only data from one class.</p>

<pre><code class="r">1:6
</code></pre>

<pre><code>## [1] 1 2 3 4 5 6
</code></pre>

<pre><code class="r">rep(1, 6)
</code></pre>

<pre><code>## [1] 1 1 1 1 1 1
</code></pre>

<pre><code class="r">seq(0, 1, 0.1)
</code></pre>

<pre><code>##  [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
</code></pre>

<pre><code class="r">v &lt;- -5:5
v[1]  # use operator [] to access vector elements, indexes start at 1
</code></pre>

<pre><code>## [1] -5
</code></pre>

<pre><code class="r">v &lt;- c(0.1, 0.2, 0.3, 0.4, 0.8, 0.9, 1, 1.5)  # function c() is used to join vectors
v
</code></pre>

<pre><code>## [1] 0.1 0.2 0.3 0.4 0.8 0.9 1.0 1.5
</code></pre>

<pre><code class="r">v[2:4]  # subvector
</code></pre>

<pre><code>## [1] 0.2 0.3 0.4
</code></pre>

<pre><code class="r">v[-1]  # vector except the first element
</code></pre>

<pre><code>## [1] 0.2 0.3 0.4 0.8 0.9 1.0 1.5
</code></pre>

<pre><code class="r">v[-3:-1]  # vector except the first three elements
</code></pre>

<pre><code>## [1] 0.4 0.8 0.9 1.0 1.5
</code></pre>

<pre><code class="r">length(v)  # size of the vector
</code></pre>

<pre><code>## [1] 8
</code></pre>

<pre><code class="r">v[length(v)]  # last element
</code></pre>

<pre><code>## [1] 1.5
</code></pre>

<pre><code class="r">v[-length(v)]  # all except last element
</code></pre>

<pre><code>## [1] 0.1 0.2 0.3 0.4 0.8 0.9 1.0
</code></pre>

<pre><code class="r">sum(v)  # sum all vector elements
</code></pre>

<pre><code>## [1] 5.2
</code></pre>

<pre><code class="r">vector()  # empty vector
</code></pre>

<pre><code>## logical(0)
</code></pre>

<pre><code class="r">vector(&quot;numeric&quot;, 10)
</code></pre>

<pre><code>##  [1] 0 0 0 0 0 0 0 0 0 0
</code></pre>

<pre><code class="r">c(1.7, &quot;a&quot;)  # implicit coercion for vectors
</code></pre>

<pre><code>## [1] &quot;1.7&quot; &quot;a&quot;
</code></pre>

<pre><code class="r">c(T, 2)
</code></pre>

<pre><code>## [1] 1 2
</code></pre>

<pre><code class="r">c(&quot;a&quot;, T)
</code></pre>

<pre><code>## [1] &quot;a&quot;    &quot;TRUE&quot;
</code></pre>

<pre><code class="r">as.numeric(1:6)  # explicit coercion
</code></pre>

<pre><code>## [1] 1 2 3 4 5 6
</code></pre>

<pre><code class="r">as.logical(0:6)
</code></pre>

<pre><code>## [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
</code></pre>

<pre><code class="r">as.character(1:6)
</code></pre>

<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot;
</code></pre>

<pre><code class="r">as.complex(1:6)
</code></pre>

<pre><code>## [1] 1+0i 2+0i 3+0i 4+0i 5+0i 6+0i
</code></pre>

<pre><code class="r">as.numeric(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))  #but...
</code></pre>

<pre><code>## Warning: NAs introduced by coercion
</code></pre>

<pre><code>## [1] NA NA NA
</code></pre>

<pre><code class="r">v1 &lt;- 1:3
names(v1) &lt;- c(&quot;data1&quot;, &quot;data2&quot;, &quot;data3&quot;)  # add names to elems
v1
</code></pre>

<pre><code>## data1 data2 data3 
##     1     2     3
</code></pre>

<pre><code class="r">v1[&quot;data1&quot;]  # accessing elements using names
</code></pre>

<pre><code>## data1 
##     1
</code></pre>

<pre><code class="r">letters  # pre-defined vector
</code></pre>

<pre><code>##  [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot;
## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot;
</code></pre>

<pre><code class="r"># more complex operations
vector &lt;- seq(1, 100, 3)
vector
</code></pre>

<pre><code>##  [1]   1   4   7  10  13  16  19  22  25  28  31  34  37  40  43  46  49
## [18]  52  55  58  61  64  67  70  73  76  79  82  85  88  91  94  97 100
</code></pre>

<pre><code class="r">u &lt;- vector%%2 == 0  # only T for pairs
u
</code></pre>

<pre><code>##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
## [12]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
## [23] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
## [34]  TRUE
</code></pre>

<pre><code class="r">v &lt;- vector[u]  # subset only with pairs
v
</code></pre>

<pre><code>##  [1]   4  10  16  22  28  34  40  46  52  58  64  70  76  82  88  94 100
</code></pre>

<pre><code class="r"># str gives the structure of a data structure
str(v)
</code></pre>

<pre><code>##  num [1:17] 4 10 16 22 28 34 40 46 52 58 ...
</code></pre>

<pre><code class="r"># typeof gives the type
typeof(v)
</code></pre>

<pre><code>## [1] &quot;double&quot;
</code></pre>

<pre><code class="r"># vectors are homogenuous structures, but R coerces to the most flexibe
# type
c(&quot;a&quot;, 1)
</code></pre>

<pre><code>## [1] &quot;a&quot; &quot;1&quot;
</code></pre>

<pre><code class="r">c(TRUE, 2)
</code></pre>

<pre><code>## [1] 1 2
</code></pre>

<pre><code class="r"># subsetting
v &lt;- 1:5
v[c(1, 2)] &lt;- 10:11
v
</code></pre>

<pre><code>## [1] 10 11  3  4  5
</code></pre>

<pre><code class="r">v[-1] &lt;- 20:23  # The length of the LHS needs to match the RHS
v
</code></pre>

<pre><code>## [1] 10 20 21 22 23
</code></pre>

<pre><code class="r">v[c(T, F)] &lt;- 0  # the subsetting cycles if it reaches the end
v
</code></pre>

<pre><code>## [1]  0 20  0 22  0
</code></pre>

<pre><code class="r"># subsetting can be used for lookup tables:
x &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;u&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;)
lookup &lt;- c(m = &quot;Male&quot;, f = &quot;Female&quot;, u = NA)
lookup[x]
</code></pre>

<pre><code>##        m        f        u        f        f        m        m 
##   &quot;Male&quot; &quot;Female&quot;       NA &quot;Female&quot; &quot;Female&quot;   &quot;Male&quot;   &quot;Male&quot;
</code></pre>

<pre><code class="r">unname(lookup[x])
</code></pre>

<pre><code>## [1] &quot;Male&quot;   &quot;Female&quot; NA       &quot;Female&quot; &quot;Female&quot; &quot;Male&quot;   &quot;Male&quot;
</code></pre>

<pre><code class="r"># Matching and merging by hand
grades &lt;- c(1, 2, 2, 3, 1)

info &lt;- data.frame(grade = 3:1, desc = c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;Poor&quot;), fail = c(F, 
    F, T))

id &lt;- match(grades, info$grade)  # returns a vector of the positions of (1st) matches of its 1st argument in its 2nd
id
</code></pre>

<pre><code>## [1] 3 2 2 1 3
</code></pre>

<pre><code class="r">info
</code></pre>

<pre><code>##   grade      desc  fail
## 1     3 Excellent FALSE
## 2     2      Good FALSE
## 3     1      Poor  TRUE
</code></pre>

<pre><code class="r">info[id, ]
</code></pre>

<pre><code>##     grade      desc  fail
## 3       1      Poor  TRUE
## 2       2      Good FALSE
## 2.1     2      Good FALSE
## 1       3 Excellent FALSE
## 3.1     1      Poor  TRUE
</code></pre>

<pre><code class="r"># NA is a logical vector!
typeof(NA)
</code></pre>

<pre><code>## [1] &quot;logical&quot;
</code></pre>

<pre><code class="r">NA &amp; TRUE
</code></pre>

<pre><code>## [1] NA
</code></pre>

<pre><code class="r">NA &amp; FALSE
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<pre><code class="r"># There are also constants NA_integer_, NA_real_, NA_complex_ and
# NA_character_ (all are reserved words)
</code></pre>

<h2>Matrixes</h2>

<p>Matrixes are vectors with dimensions</p>

<pre><code class="r">m &lt;- 1:16  # just a vector for now
m
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
</code></pre>

<pre><code class="r">class(m)  # function to determine the object&#39;s type
</code></pre>

<pre><code>## [1] &quot;integer&quot;
</code></pre>

<pre><code class="r">dim(m) &lt;- c(4, 4)  # make a matrix out of it (rows, columns)
m
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    5    9   13
## [2,]    2    6   10   14
## [3,]    3    7   11   15
## [4,]    4    8   12   16
</code></pre>

<pre><code class="r">class(m)
</code></pre>

<pre><code>## [1] &quot;matrix&quot;
</code></pre>

<pre><code class="r">dim(m) &lt;- c(2, 8)  # make a diff matrix
m
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    1    3    5    7    9   11   13   15
## [2,]    2    4    6    8   10   12   14   16
</code></pre>

<pre><code class="r">dim(m) &lt;- c(4, 2, 2)  # make a 3D matrix
m
</code></pre>

<pre><code>## , , 1
## 
##      [,1] [,2]
## [1,]    1    5
## [2,]    2    6
## [3,]    3    7
## [4,]    4    8
## 
## , , 2
## 
##      [,1] [,2]
## [1,]    9   13
## [2,]   10   14
## [3,]   11   15
## [4,]   12   16
</code></pre>

<pre><code class="r">m &lt;- matrix(1:16, nrow = 2, ncol = 8, byrow = T)
m
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    1    2    3    4    5    6    7    8
## [2,]    9   10   11   12   13   14   15   16
</code></pre>

<pre><code class="r">m &lt;- matrix(1:16, nrow = 2, ncol = 8, dimnames = list(c(&quot;row.1&quot;, &quot;row.2&quot;), letters[1:8]))
m
</code></pre>

<pre><code>##       a b c d  e  f  g  h
## row.1 1 3 5 7  9 11 13 15
## row.2 2 4 6 8 10 12 14 16
</code></pre>

<pre><code class="r">m &lt;- matrix(1:6, 3, 2)
dim(m)
</code></pre>

<pre><code>## [1] 3 2
</code></pre>

<pre><code class="r">m
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
</code></pre>

<pre><code class="r">dim(m) &lt;- c(2, 3)
m
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
</code></pre>

<pre><code class="r">m[1, ]  # first row
</code></pre>

<pre><code>## [1] 1 3 5
</code></pre>

<pre><code class="r">m[, 2]  # second column
</code></pre>

<pre><code>## [1] 3 4
</code></pre>

<pre><code class="r">m[1, 2]  # element in first row, 2nd col
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">m[, c(1, 3)]  # the first and third column
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    5
## [2,]    2    6
</code></pre>

<pre><code class="r">m1 &lt;- 1:3
m2 &lt;- 10:12
cbind(m1, m2)  # matrix formation with binding cols or rows
</code></pre>

<pre><code>##      m1 m2
## [1,]  1 10
## [2,]  2 11
## [3,]  3 12
</code></pre>

<pre><code class="r">rbind(m1, m2)
</code></pre>

<pre><code>##    [,1] [,2] [,3]
## m1    1    2    3
## m2   10   11   12
</code></pre>

<pre><code class="r">m1 &lt;- matrix(1:9, nrow = 3, ncol = 3)
m2 &lt;- matrix(seq(18, 2, -2), nrow = 3, ncol = 3)
m1
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
</code></pre>

<pre><code class="r">m2
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]   18   12    6
## [2,]   16   10    4
## [3,]   14    8    2
</code></pre>

<pre><code class="r">m1 + m2
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]   19   16   13
## [2,]   18   15   12
## [3,]   17   14   11
</code></pre>

<pre><code class="r">m1 * m2  # product item by item
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]   18   48   42
## [2,]   32   50   32
## [3,]   42   48   18
</code></pre>

<pre><code class="r">m1 %*% m2  # real matrix multiplication
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]  180  108   36
## [2,]  228  138   48
## [3,]  276  168   60
</code></pre>

<pre><code class="r">t(matrix(1:6, nrow = 2, ncol = 3))  # transpose
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
</code></pre>

<pre><code class="r">
sum(1:5 * 5:1)  # inner vector product
</code></pre>

<pre><code>## [1] 35
</code></pre>

<pre><code class="r">outer(1:5, 5:1)  # outer vector product
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    5    4    3    2    1
## [2,]   10    8    6    4    2
## [3,]   15   12    9    6    3
## [4,]   20   16   12    8    4
## [5,]   25   20   15   10    5
</code></pre>

<pre><code class="r">
diag(x = 1, nrow = 5, ncol = 3)
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1
## [4,]    0    0    0
## [5,]    0    0    0
</code></pre>

<pre><code class="r">m3 &lt;- diag(1:4)  # makes a diagonal matrix using the vector to initialize diagonal
m3
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    0    0    0
## [2,]    0    2    0    0
## [3,]    0    0    3    0
## [4,]    0    0    0    4
</code></pre>

<pre><code class="r">m3[upper.tri(m3, diag = T)] &lt;- NA
m3
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   NA   NA   NA   NA
## [2,]    0   NA   NA   NA
## [3,]    0    0   NA   NA
## [4,]    0    0    0   NA
</code></pre>

<h2>Lists</h2>

<p>Lists can contain values of different types (including lists)</p>

<pre><code class="r">l1 &lt;- list(atr1 = 1:4, atr2 = 0.6)
l1
</code></pre>

<pre><code>## $atr1
## [1] 1 2 3 4
## 
## $atr2
## [1] 0.6
</code></pre>

<pre><code class="r">l1[1]
</code></pre>

<pre><code>## $atr1
## [1] 1 2 3 4
</code></pre>

<pre><code class="r">l1[&quot;atr1&quot;]  # same thing
</code></pre>

<pre><code>## $atr1
## [1] 1 2 3 4
</code></pre>

<pre><code class="r">l1[[1]]  # operator [[]] extracts a single element
</code></pre>

<pre><code>## [1] 1 2 3 4
</code></pre>

<pre><code class="r">class(l1[[1]])
</code></pre>

<pre><code>## [1] &quot;integer&quot;
</code></pre>

<pre><code class="r">class(l1[1])
</code></pre>

<pre><code>## [1] &quot;list&quot;
</code></pre>

<pre><code class="r">l1$atr1  # operator $ extracts part of the object
</code></pre>

<pre><code>## [1] 1 2 3 4
</code></pre>

<pre><code class="r">l1[[&quot;atr1&quot;]]  # same thing, except $ does partial matching
</code></pre>

<pre><code>## [1] 1 2 3 4
</code></pre>

<pre><code class="r">l2 &lt;- list(atr1 = 1:4, atr2 = 0.6, atr3 = &quot;hello&quot;)
l2
</code></pre>

<pre><code>## $atr1
## [1] 1 2 3 4
## 
## $atr2
## [1] 0.6
## 
## $atr3
## [1] &quot;hello&quot;
</code></pre>

<pre><code class="r">l2[c(1, 3)]
</code></pre>

<pre><code>## $atr1
## [1] 1 2 3 4
## 
## $atr3
## [1] &quot;hello&quot;
</code></pre>

<pre><code class="r">l3 &lt;- list(a = list(10, 12, 14), b = c(3.14, 2.81))
l3
</code></pre>

<pre><code>## $a
## $a[[1]]
## [1] 10
## 
## $a[[2]]
## [1] 12
## 
## $a[[3]]
## [1] 14
## 
## 
## $b
## [1] 3.14 2.81
</code></pre>

<pre><code class="r">l3[[c(1, 3)]]
</code></pre>

<pre><code>## [1] 14
</code></pre>

<pre><code class="r">l3[[1]][[3]]
</code></pre>

<pre><code>## [1] 14
</code></pre>

<pre><code class="r">l3a &lt;- list(a = list(b = list(c = list(d = 1))))
l3a
</code></pre>

<pre><code>## $a
## $a$b
## $a$b$c
## $a$b$c$d
## [1] 1
</code></pre>

<pre><code class="r">l3a[[c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)]]
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">l4 &lt;- list(aarvark = 1.5, ox = 3.4)
l4$a  # partial matching is possible with $ (proceed with caution!)
</code></pre>

<pre><code>## [1] 1.5
</code></pre>

<pre><code class="r">l5 &lt;- list(list(list(list())))
str(l5)
</code></pre>

<pre><code>## List of 1
##  $ :List of 1
##   ..$ :List of 1
##   .. ..$ : list()
</code></pre>

<pre><code class="r">is.recursive(l5)  # returns TRUE if arg has a recursive (list-like) structure
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r"># c() will combine several lists into one. If given a combination of
# atomic vectors and lists, c() will coerce the vectors to list before
# combining them.
l6 &lt;- list(list(1, 2), c(3, 4))
l7 &lt;- c(list(1, 2), c(3, 4))
str(l6)
</code></pre>

<pre><code>## List of 2
##  $ :List of 2
##   ..$ : num 1
##   ..$ : num 2
##  $ : num [1:2] 3 4
</code></pre>

<pre><code class="r">str(l7)
</code></pre>

<pre><code>## List of 4
##  $ : num 1
##  $ : num 2
##  $ : num 3
##  $ : num 4
</code></pre>

<pre><code class="r"># coerce with as.list(...)  check with is.list(...)  convert to vector
# with unlist()
</code></pre>

<blockquote>
<p>Lists are used to build up many of the more complicated data structures in R. For example, both data frames (described below), and linear models objects (as produced by lm()) are lists <a href="http://adv-r.had.co.nz/Data-structures.html">ref</a></p>
</blockquote>

<h2>Data Frames</h2>

<p>Data frames are used to store tabular data, they are lists of same-length vectors vertically aligned. Useful to keep datasets</p>

<pre><code class="r">df &lt;- data.frame(col1 = 1:4, col2 = c(TRUE, TRUE, FALSE, TRUE))
df
</code></pre>

<pre><code>##   col1  col2
## 1    1  TRUE
## 2    2  TRUE
## 3    3 FALSE
## 4    4  TRUE
</code></pre>

<pre><code class="r">df$col1  # show a column, ie, an attribute
</code></pre>

<pre><code>## [1] 1 2 3 4
</code></pre>

<pre><code class="r">df[, 2]
</code></pre>

<pre><code>## [1]  TRUE  TRUE FALSE  TRUE
</code></pre>

<pre><code class="r">df[1, ]  # show a row, ie, an observation
</code></pre>

<pre><code>##   col1 col2
## 1    1 TRUE
</code></pre>

<pre><code class="r">df$newAtr &lt;- letters[1:4]  # add a new attribute
df
</code></pre>

<pre><code>##   col1  col2 newAtr
## 1    1  TRUE      a
## 2    2  TRUE      b
## 3    3 FALSE      c
## 4    4  TRUE      d
</code></pre>

<pre><code class="r">names(df)  # the name of the columns
</code></pre>

<pre><code>## [1] &quot;col1&quot;   &quot;col2&quot;   &quot;newAtr&quot;
</code></pre>

<pre><code class="r">row.names(df)  # the name of the rows
</code></pre>

<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot;
</code></pre>

<pre><code class="r">row.names(df) &lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;3rd&quot;, &quot;4th&quot;)
df
</code></pre>

<pre><code>##        col1  col2 newAtr
## first     1  TRUE      a
## second    2  TRUE      b
## 3rd       3 FALSE      c
## 4th       4  TRUE      d
</code></pre>

<pre><code class="r">nrow(df)  # number of rows
</code></pre>

<pre><code>## [1] 4
</code></pre>

<pre><code class="r">ncol(df)  # number of cols
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">df[5, ] = list(5, FALSE)  # add a new observation

df[df$col2 == T, ]  # select observations where col2 is true
</code></pre>

<pre><code>##        col1 col2 newAtr
## first     1 TRUE      a
## second    2 TRUE      b
## 4th       4 TRUE      d
</code></pre>

<pre><code class="r">mean(df$col1)  # find statistics over a certain column
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">df &lt;- data.frame(x = 1:3)  # it is possible for a data frame to have a column that is a list:
df$y &lt;- list(1:2, 1:3, 1:4)
df
</code></pre>

<pre><code>##   x          y
## 1 1       1, 2
## 2 2    1, 2, 3
## 3 3 1, 2, 3, 4
</code></pre>

<h2>Attributes</h2>

<p>All objects can have arbitrary additional attributes. These can be thought of as a named list (with unique names). Attributes can be accessed individually with attr() or all at once (as a list) with attributes().</p>

<pre><code class="r">v1 &lt;- 1:5
attr(v1, &quot;text&quot;) &lt;- &quot;this is a vector&quot;
v1
</code></pre>

<pre><code>## [1] 1 2 3 4 5
## attr(,&quot;text&quot;)
## [1] &quot;this is a vector&quot;
</code></pre>

<pre><code class="r">str(v1)
</code></pre>

<pre><code>##  atomic [1:5] 1 2 3 4 5
##  - attr(*, &quot;text&quot;)= chr &quot;this is a vector&quot;
</code></pre>

<pre><code class="r"># The structure() function returns a new object with modified attributes
structure(1:10, my_attribute = &quot;This is a vector&quot;)
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10
## attr(,&quot;my_attribute&quot;)
## [1] &quot;This is a vector&quot;
</code></pre>

<pre><code class="r"># There are 3 special attributes: names(), character vector of element
# names class(), used to implement the S3 object system, described in the
# next section dim(), used to turn vectors into high-dimensional
# structures
</code></pre>

<h2>Names</h2>

<p>You can name a vector in three ways:</p>

<ul>
<li>During creation: x &lt;- c(a = 1, b = 2, c = 3)</li>
<li>By modifying an existing vector: x &lt;- 1:3; names(x) &lt;- c(&ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo;)</li>
<li>By creating a modified vector: x &lt;- setNames(1:3, c(&ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo;))</li>
</ul>

<p>Names should be unique</p>

<pre><code class="r">v1 &lt;- c(a = 1, 2, 3)
v1
</code></pre>

<pre><code>## a     
## 1 2 3
</code></pre>

<pre><code class="r">names(v1) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
v1
</code></pre>

<pre><code>## a b c 
## 1 2 3
</code></pre>

<pre><code class="r">names(v1) &lt;- NULL  # erase names
v1
</code></pre>

<pre><code>## [1] 1 2 3
</code></pre>

<h2>Factors</h2>

<p>A factor is a vector that can contain only predefined values.</p>

<p>Factors have two key attributes: their class(), &ldquo;factor&rdquo;, which controls their behaviour; and their levels(), the set of allowed values.</p>

<p>Factors represent categorical data, can be ordered or not
can be seen an integer vector where each int has a label
used to store tabular data.</p>

<p>Check <a href="http://www.stat.berkeley.edu/classes/s133/factors.html">www.stat.berkeley.edu/classes/s133/factors.html</a> for more information</p>

<pre><code class="r">f1 &lt;- factor(c(&quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;yes&quot;))
f1
</code></pre>

<pre><code>## [1] yes no  yes yes
## Levels: no yes
</code></pre>

<pre><code class="r"># make a contingency table, ie, displays the frequency distribution of the
# variables
table(f1)
</code></pre>

<pre><code>## f1
##  no yes 
##   1   3
</code></pre>

<pre><code class="r">f1a &lt;- factor(c(&quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;yes&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;))  # redefine the order of the levels
f1a
</code></pre>

<pre><code>## [1] yes no  yes yes
## Levels: yes no
</code></pre>

<pre><code class="r">levels(f1)
</code></pre>

<pre><code>## [1] &quot;no&quot;  &quot;yes&quot;
</code></pre>

<pre><code class="r"># Egs of use
set.seed(143)  # deterministic random generation
lets = factor(sample(letters, size = 15, replace = T))
lets
</code></pre>

<pre><code>##  [1] y a t k b y p p p k l e y h w
## Levels: a b e h k l p t w y
</code></pre>

<pre><code class="r">levels(lets)
</code></pre>

<pre><code>##  [1] &quot;a&quot; &quot;b&quot; &quot;e&quot; &quot;h&quot; &quot;k&quot; &quot;l&quot; &quot;p&quot; &quot;t&quot; &quot;w&quot; &quot;y&quot;
</code></pre>

<pre><code class="r">table(lets[1:10])
</code></pre>

<pre><code>## 
## a b e h k l p t w y 
## 1 1 0 0 2 0 3 1 0 2
</code></pre>

<pre><code class="r"># A strange eg: each value of the factor is translated into i, where i is
# its i-th level. Since &#39;p&#39; is a vector of one position, only where &#39;lets&#39;
# as values &#39;a&#39; (which are elements of the 1st level) does the result is
# not NA
&quot;p&quot;[lets]
</code></pre>

<pre><code>##  [1] NA  &quot;p&quot; NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA
</code></pre>

<pre><code class="r">levels(lets)[lets]  # left as an eg :-)
</code></pre>

<pre><code>##  [1] &quot;y&quot; &quot;a&quot; &quot;t&quot; &quot;k&quot; &quot;b&quot; &quot;y&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;k&quot; &quot;l&quot; &quot;e&quot; &quot;y&quot; &quot;h&quot; &quot;w&quot;
</code></pre>

<blockquote>
<p>While factors look (and often behave) like character vectors, they are actually integers under the hood and you need to be careful when treating them like strings. Some string methods (like gsub() and grepl()) will coerce factors to strings, while others (like nchar()) will throw an error, and still others (like c()) will use the underlying integer IDs. For this reason, it&#39;s usually best to explicitly convert factors to strings when modifying their levels. </p>

<p>Unfortunately, most data loading functions in R automatically convert character vectors to factors. This is suboptimal, because there&#39;s no way for those functions to know the set of all possible levels and their optimal order. Instead, use the argument stringsAsFactors = FALSE to suppress this behaviour, and then manually convert character vectors to factors using your knowledge of the data. <a href="http://adv-r.had.co.nz/Data-structures.html">ref</a></p>
</blockquote>

</body>

</html>

